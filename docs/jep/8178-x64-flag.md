# JEP 8178: The Future of the X64 Flag

This document discusses the future of the `jax_enable_x64` flag in JAX.

## Current State: what is the X64 flag?

In short, the `jax_enable_x64` flag allows JAX to be executed in one of two modes.
With `jax_enable_x64=true`, various {func}`jax.numpy` functions will default to creating
64-bit arrays.
With `jax_enable_x64=false`, these functions will instead default to creating 32-bit arrays.
What is more, when `jax_enable_x64=false`, it is **impossible** to create an array of 64-bit values in JAX.

The value of the `jax_enable_x64` flag defaults to `False`, meaning that the user must explicitly opt-in to creating 64-bit values.
This is covered more completely in [ðŸ”ª JAX - The Sharp Bits ðŸ”ª: Double (64bit) precision](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision).

## Why have an X64 flag?

The reason for this modalism in JAX's API is performance: JAX code can run on accelerators like GPU and TPU, and 32-bit computations are often *much* more performant than equivalent 64-bit computations.
Early in JAX's development, it was found that 64-bit values were sneaking into large JAX pipelines through e.g. numpy-style dtype promotion, numpy API defaults, and other means, and the X64 flag was added as a quick remedy for these kinds of performance issues.
Because JAX's early uses were primaily geared toward neural network models running on accelerators, it made sense to default to `jax_enable_x64=False`, while giving users the ability to explicitly opt-in to 64-bit values when desired by setting the flag to True.

## Problems with the X64 flag

The existence of such a flag is confusing and problematic, for several reasons:

1. **User confusion**: having program behavior depend on global state can lead to user confusion, and to difficult-to-predict behavior for any given code block.
2. **Inflexibility**: there is no supported way to use explicitly-specified 64-bit types unless you enable the global flag. Thus, performing efficient operations and precise operations in the same session becomes problematic.
3. **Developer friction**: it effectively doubles the amount of CI tests that must be run for any update to JAX or packages that depend on it, and doubles the cognitive load required for any change.

These problems have led the JAX team to explore the possibility of a new approach.

## Potential Solutions

Over the past year or two, JAX team members have explored a number of possible alternatives to the current approach to 64-bit values.
Here are a few of the ideas:

### Context Managers
One lightweight approach we've attempted is to largely keep the current state of things, but add context managers (i.e. {func}`jax.experimental.enable_x64` and {func}`jax.experimental.disable_x64`) to allow the restriction to be temporarily enforced and lifted. This is a partial solution that helps with the inflexibility problem, but does not necessarily address user confusion and developer friction.

Additionally, it turns out that due to the way that X64 is implemented (through dtype canonicalization) along with JAX's tracing model, there is no easy way to make such context managers interact correctly with transforms like `jit`.
For details, see {jax-issue}`#5982` and {jax-issue}`#7577`.
This issue is fundamental enough that we chose not to pursue the context manager approach further.

### Enabling X64 Permanently
To address all three of the above problems, one option we've pursued is to enable X64 permanently.
Care is needed, however, in order to avoid the problems that led to its creation in the first place: namely, 64-bit values sneaking into computations that would otherwise be 32-bit.
Over the past year plus, we've gradually been addressing such issues across the JAX package; these additions are attached to {jax-issue}`#8178`.
A few worth mentioning:

- In [JEP 9407](https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html) we describe new type promotion semantics for JAX that avoid many of the problematic 64-bit promotions that occur within numpy's type promotion system.
- Related to this, in {jax-issue}`#10824` we added the `jax_numpy_dtype_promotion` flag, which allows users to contextually turn off implicit dtype promotion that may result in an inadvertent 64-bit value.
- We set `jax_numpy_dtype_promotion='strict'` by default in JAX's test suite, which revealed numerous places across the package where input types were being promoted, often inadvertently to 64-bit types.
- We added a `jax_default_dtype_bits` flag that allows us to optionally specify that `jax.numpy` functions should produce 32-bit types by default.
- Based on the above, we made countless small modifications across the package to tighten-up the types introduces by JAX API functions.

Still, there are a few potential sources of 64-bit values that pose a challenge.
Namely:

- Python scalars & weak types: when a user uses something like `np.pi`, it is a Python float with 64 bits of precision. Because some users need the full precision of such values, we cannot pre-emptively truncate them to 32 bits. For this purpose, we introduced the idea of "weak types", in which the value is stored as 64-bit, but will be demoted in an operation with a 32-bit value. Still, these "raw" weak types in some situations can become 64-bit arrays that may end up propagating through a computation (a simple example is `jnp.broadcast_to(np.pi, (1000, 1000)))`.
- NumPy array inputs: numpy arrays default to 64-bit. If a user writes `np.arange(10)` rather than `jnp.arange(10)`, the result is always a (strongly-typed) 64-bit array. The X64 flag causes this to be converted to 32-bit at the JAX function boundary. One might ask whether we should convert numpy array inputs to the default type, but unfortunately it's not this simple, as internally JAX uses numpy scalar values as constants (and allowing 64-bit constants is an important part of supporting 64-bit JAX computations).

These challenges mean that if we were to set `jax_enable_x64=False` along with `jax_default_dtype_bits=32`, there would still be ways for 64-bit values to sneak into computations without the user realizing.

### Adding more guardrails

To address some of the challenges associated with enabling X64 permanently, we've experimented with several kinds of additional guardrails in the form of context managers that users could use when they want to ensure that no 64-bit types are used.
For example, a `jax_warn_on_x64` context manager might show the user a warning when a 64-bit value is generated.
This has proven to be somewhat challenging, for some of the same reasons that the `enable_x64` context manager is challenging across JIT boundaries.

## Plan going forward

TODO: what's the best approach looking forward?
